# 자바 메모리 관리

- contents
    - Java의 Stack과 Heap
    - 가비지 컬렉션

### Java의 Stack과 Heap

![Stack&Heap](https://s3.ap-northeast-2.amazonaws.com/yaboong-blog-static-resources/java/javamemory-stack-and-heap-dzone.jpg)
*Image from 'https://dzone.com/articles/java-memory-management'*

#### Stack
- Heap 영역에 생성된 Object 타입의 데이터의 참조값이 할당된다.
- 원시타입의 데이터가 값과 함께 할당된다.
- 지역변수들은 scope에 따른 visibility를 가진다.
- 각 Thread는 자신만의 Stack을 가진다.

Stack에는 Heap 영역에 생성된 Object 타입의 데이터들에 대한 참조를 위한 값들이 할당된다. 또한, 원시타입(primitive type) - byte, short, int, long, double, float, boolean, char 타입의 데이터들이 할당된다. 이 때 원시타입의 데이터들에 대해서는 참조값을 저장하는 것이 아니라 실제 값을 stack에 직접 저장하게 된다.

Stack 영역에 있는 변수들은 visibility를 가진다. 변수 scope에 대한 개념이다. 전역변수가 아닌 지역변수가 foo()라는 함수 내에서 Stack에 할당된 경우, 해당 지역변순느 다른 함수에서 접근할 수 없다. 예를 들어, foo()라는 함수에서 bar()함수를 호출하고 bar()함수의 종료되는 중괄호 } 가 실행된 경우(함수가 종료된 경우), bar() 함수 내부엣 선언한 모든 지역변수들은 stack에서 pop되어 사라진다.

Stack 메모리는 Thread 하나당 하나씩 할당된다. 즉, 쓰레드 하나가 새롭게 생성되는 순간 해당 스레드를 위한 stack도 함께 생성되며, 각 쓰레드에서 다른 쓰레드의 stack 영역에는 접근할 수 없다.

#### Heap
- Heap 영역에는 주로 긴 생명주기를 가지는 데이터들이 저장된다. (대부분의 오브젝트는 크기가 크고, 서로 다른 코드블럭에서 공유되는 경우가 많다.)
- 애플리케이션의 모든 메모리 중 stack에 있는 데이터를 제외한 부분이라고 보면 된다.
- 모든 Object타입(Integer, String, ArrayList ...)은 Heap영역에 생성된다.
- 몇 개의 쓰레드가 존재하든 상관없이 단 하나의 Heap영역만 존재한다.
- Heap영역에 있는 오브젝트들을 가리키는 레퍼런스 변수가 stack에 올라가게 된다.
- **String과 모든 Wrapper 클래스는 Immutable이다. 그래서 Heap에 같은 오브젝트를 레퍼런스 하고 있는 경우라도, 새로운 연산이 적용되는 순간 새로운 오브젝트가 Heap에 새롭게 할당된다.**

### 가비지 컬렉션

#### Java Virtual Machine(JVM)
C나 C++에서는 OS레벨의 메모리에 직접 접근하기 때문에 free()라는 메소드를 호출하여 할당받았던 메모리를 명시적으로 해제해주어야 한다. 그렇지 않으면 memory leak이 발생하게 되고, 현재 실행중인 프로그램에서 memory leak이 발생하면 다른 프로그램에도 영향을 끼칠 수 있다.

반면, 자바는 OS의 메모리 영역에 직접적으로 접근하지 않고 JVM이라는 가상머신을 이용해서 간접적으로 접근한다. JVM은 C로 쓰여진 또 다른 프로그램인데, 오브젝트가 필요해지지 않는 시점에서 알아서 free()를 수행하여 메모리를 확보한다. 웹 애플리케이션을 만들 때 모든 것을 직접 다 개발하여 쓰기보다 검증된 라이브러리나 프레임워크를 이용하는 것이 더 안전하고 편리한 것처럼, 메모리 관리라는 까다로운 부분을 자바 가상머신에 모두 맡겨버리는 것이다.

프로그램 실행 시 JVM옵션을 주어서 OS에 요청한 사이즈 만큼의 메모리를 할당 받아서 실행하게 된다. 할당받은 이상의 메모리를 사용하게 되면 에러가 나면서 자동으로 프로그램이 종료된다. 그러므로 현재 프로세스에서 메모리 누수가 발생하더라도 현재 실행중인 것만 죽고, 다른 것에는 영향을 주지 않는다.

이렇게 자바는 가상머신을 사용함으로써(운영체제로부터 독립적이라는 장점 외에도) OS레벨에서의 memory leak은 불가능하게 된다는 장점이 있다.

자바가 메모리 누수현상을 방지하는 또 다른 방법이 가비지 컬렉션이다.

#### Garbage Collection
가바지 컬렉션이라는 개념은 자바에서 처음 사용된 것이 아니다. LISP 라는 언어에서 처음 도입된 개념이다. 하지만 자바가 가비지 컬렉션이라는 개념을 더욱 대중화 시킨데 기여한 부분은 있다.

프로그래머는 힙을 사용할 수 있는 만큼 자유롭게 사용하고, 더 이상 사용되지 않는 오브젝트들은 가비지 컬렉션을 담당하는 프로세스가 자동으로 메모리에서 제거하도록 하는 것이 가바지 컬렉션의 기본 개념이다.

자바는 가비지 컬렉션에 아주 단순한 규칙을 적용한다.
*Heap 영역의 오브젝트 중 stack에서 도달 불가능한(Unreachable) 오브젝트들은 가비지 컬렉션의 대상이 된다.*

#### System.gc()
System.gc()를 호출하여 명시적으로 가비지 컬렉션이 일어나도록 코드를 삽입할 수 있지만, 모든 스레드가 중단되기 땜누에 코드단에서 호출하는 짓은 하면 안된다.


### 참고
- https://yaboong.github.io/java/2018/05/26/java-memory-management/
- https://yaboong.github.io/java/2018/06/09/java-garbage-collection/