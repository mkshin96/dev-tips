# 연속 메모리 할당

- 다중 프로그래밍 환경
    - 부팅 직후 메모리 상태 : OS + big single hole
    - 프로세스 생성 & 종료 반복 → scattered holes
- 메모리 단편화
    - Hole들이 불연속하게 흩어져 있기 때문에 프로세스 적재 불가
    - 외부 단편화 발생
    - 외부 단편화를 최소화하려면?

### 연속 메모리 할당 방식

---

- First-Fit
    - Hole(메모리) 중 프로그램이 들어갈 수 있는 가장 처음 홀에 올라감
- Best-Fit
- Worst-Fit
- 할당 방식 성능 비교 : 속도 및 메모리 이용률
    - 속도 : First-Fit
    - 이용률 : First-Fit, Best-Fit (비슷, 많은 경우를 실험해보니 비슷하게 나옴)
- 외부 단편화로 인한 메모리 낭비 : 1/3 수준(사용 불가) → Best로 하더라도 외부 단편화가 사라지는 것은 아니다.
    - Compaction : 흩어진 홀들을 한 곳으로 모음, 최적 알고리즘 없음, 고부담
    - 다른방법은?
    - 프로세스를 메모리에 연속으로 들어가야 한다고 생각하여 이런 문제가 발생한 것, 연속 안하면 안될까? **페이징**

### 페이징

---

- 일정한 단위로 자르는 것
    - 홀, 프로세스
    - 프로세스를 잘라서 넣으면 실행이 될까? 못 돌것같음
    - 연속 안해도 돌 수 있는 방법은? CPU를 속이면 됨
    - MMU에 재배치 레지스터를 여러 개 둠
        - 프로세스가 160kb라고 가정하고 10kb씩 자르면 16개가 나옴
        - MMU에 재배치 레지스터를 16개 두고
        - CPU가 16개를 실행시킬 때
- 프로세스를 자르는 것
    - 페이지
- 메모리를 자르는 것
    - 프레임
- 페이지와 프레임의 크기는 같아야 한다.
- 프로세스를 일정 크기(=페이지)로 잘라서 메모리에!
    - 프로세스는 페이지의 집합
    - 메모리는 프레임의 집합
- 페이지를 프레임에 할당
    - MMU 내의 재배치 레지스터 값을 바꿈으로써
    - CPU는 프로세스가 연속된 메모리 공간에 위치 한다고 착각
    - MMU는 페이지 테이블이 된다.
        - 재배치 레지스터가 테이블 형식으로 들어있음
        - 페이징 목적으로 사용되기 때문에
        - 페이지 테이블

### *이로써 외부 단편화는 모두 해결됨*

- 주소 변환
    - 논리 주소
        - CPU가 내는 주소는 2진수로 표현
        - 하위 n비트는 오프셋 또는 변위(displacement)
        - 상위 m-n비트는 페이지 번호
    - 주소변환 : 논라주소 → 물리주소
        - 페이지 번호(p)는 페이지 테이블 인덱스 값
        - p에 해당되는 테이블 내용이 프레임 번호
        - 변위는 변하지 않음
    - 논리주소 50번지, 페이지 사이즈 : 16byte, 물리주소는?
        - 50(10) → 110010(2)
        - 16 → 2^4 → 11(페이지 넘버)/0010(d, 변위)
        - 페이지 테이블(MMU)의 내용(~는 아무 숫자, 필요없어서 안적음)
            - 0  ~
            - 1  ~
            - 2  ~
            - 3  8
            - 4  ~
            - 5  ~
        - 페이지 넘버가 11이기 때문에 페이지 테이블의 3의 값인 8이 들어감
            - 10000010(2) → 130
        - 따라서 물리 주소는 130번지
    - 페이지(프로세스의 조각)의 순서가 연속되지 않아도, CPU는 MMU의 재배치 레지스터때문에 연속된 줄 안다.