# 프레임 할당

- process mgmt
    - cpu scheduling
    - process synchronization
- memoty mgmt
    - paging
    - virtual memory
        - demand paging
            - 요구되어지는 페이지만 메모리에 올림
            - 올리다 보면 메모리가 가득 참, 어떤 페이지를 victim으로 쫓아낼 것인가
                - 페이지 교체 알고리즘
                    - FIFO
                    - OPT(Optimal) : 최적화, 앞으로 가장 사용 안될 페이지를 victim으로
                    - LRU : 최근에 가장 사용 안된 Page
                - Allocation of Frame
                    - 어떤 프로세스에게 얼마 만큼의 메모리를 줄 것인가
                    - Pure Demand Paging
                        - 고민 안해도 됨, 필요로 하는 페이지에게 프레임을 할당하면 되기 때문 → 하지만 PF(Page Fault)가 너무 많음
                    - 정적 할당
                        - 모든 프로세스에게 프레임을 같이 할당
                    - 비례 할당
                        - 프로세스의 사이즈가 큰 프로세스에게 프레임을 많이 할당
                        - 프로세스의 사이즈가 크다고해서 프레임이 많이 필요하지 않을 수도 있다.

    ### 동적 할당

    ---

    - Working Set Model
        - Locality vs working set
        - Working set window
        - Working set 크기 만큼의 프레임 할당
    - Page-Fault Frequency(PFF)
        - Page Fault 발생 비율의 상한/하한선
        - 상한선 초과 프로세스에 더 많은 프레임 할당
        - 하한선 이하 프로세스의 프레임은 회수
    - 세로축 : CPU가 참조하는 페이지의 번호(개수?), 가로축 : 시간
        - 점들을 찍어보면
        - CPU가 주소를 내는데 특정 시간대에는 특정 프레임(?)에 모여져 있다.
        - Locality
        - 특정 시간대를 기준으로 프레임을 프로세스에게 나눠주면 된다.
        - 페이지 폴트가 너무 빈번하게 일어나는 것 → 쓰레싱
        - Locality를 포함할 수 있는 메모리만 할당하면 된다.
            - 교과서에 있는 내용
            - 실제로 돌려봐야 안다.
            - 미래를 예측하는 방법이 Working Set
    - Working Set
        - 특정 시간대에 어떤 페이지가 사용되었는지 기억(저장)
        - 특정 시간의 프레임의 양을 정하는 것은 과거를 보고 결정
            - 과거에 어떤 페이지가 사용되었는가
                - 사용된 페이지 → Working Set
            - 그리고 특정시간에서 어느정도의 과거를 볼 것인가
                - 다 볼수는 없음
            - 특정 시간에서 과거까지의 기간 → Working Set Window
            - Working Set을 보고 프레임을 할당
    - Page Fault Frequency
        - 가로축 : number of frames (할당된 프레임의 개수, 해당 프로세스에게 몇 개의 프레임을 할당할 것인가), 세로축 : 페이지 폴트가 일어나는 비율
        - 반비례 그래프가 나옴
        - OS는 상한선과 하한선을 기억해둠
        - OS의 메모리 관리 부서로 하여금 페이지 폴트가 일어나는 횟수를 계속 감시하도록 함
        - 페이지 폴트가 상한선보다 많이 일어나면 프레임을 더 할당함
        - 하한선 이하의 프로세스 프레임은 할당
    - 이외에도 여러개의 동적 프레임 할당이 있음

    ### 페이지 크기(Page Size)

    ---

    - 한 페이지는 어느 정도로 자르는 걸까?
    - 일반적으로 4KB → 4MB
    - 점차 커지는 경향
    - 페이지 크기 영향
        - 내부 단편화
            - 페이지의 크기가 커질 수록 커진다.
            - 페이지의 크기가 작을 수록 내부 단편화가 줄기 때문에 좋음.
        - Page-in, Page-out 시간
            - 페이지 폴트 시간이 길다.
            - 페이지의 크기가 클수록 좋다.
            - 하드 디스크의 대부분의 시간은 헤더를 움직이는 시간
            - 헤더를 한번 움직였을 때 더 큰 크기의 페이지를 읽어오는 것이 좋음
        - 페이지 테이블 크기
            - 페이지 테이블은 SRAM으로 만들기 때문에 비쌈, 따라서 페이지 테이블의 엔트리 개수가 작으면 좋다.
            - 페이지의 사이즈가 크면 좋다.
            - 페이지의 크기가 크면 프로세스가 낮은 개수로 페이징 되기 때문
        - Memory Resolution(해상도)
            - 진짜 필요한 내용만 메모리에 있게 된다.
            - 페이지의 크기가 작을 수록 좋다.
        - Page Fault 발생 확률
            - 페이지의 크기가 클수록 좋다
            - 지역성의 원리 때문
                - CPU가 100번지를 냈다면 다음은 104번지, 다음은 108번지 ...
                - 일 것이기 때문

    ### 기술 동향

    ---

    - 페이지 테이블
        - 원래의 별도의 chip(TLB 캐시, Translation Look Aside Buffer)
        - 페이지 테이블을 뭘로 만들것인가
            - CPU (레지스터)
            - 메모리
                - 속도가 너무 느려짐
        - 기술 발달에 따라 캐시 메모리는 on-chip형태로
            - cpu와 메모리 사이에는 캐시 메모리가 있음(Level1 캐시, Level2 캐시)
                - 기술 발달에 따라 캐시 메모리를 CPU안에 넣음
                - 역시 TLB도 CPU 안에 넣음
        - TLB 역시 on-chip 내장