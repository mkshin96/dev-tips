# 가상 메모리

- 세그멘테이션
- 가상메모리

### *세그멘테이션*

---

- 앞서 말한 세그멘테이션의 단점은 외부단편화가 심하다.
- 그래서 나온 것이 페이지드 세그멘테이션(Paged Segmentation)
    - 처음에는 프로세스를 세그멘테이션으로 자르고, 세그멘테이션을 다시 페이징하는 것
    - 공유와 보호에 좋고 외부단편화가 일어나지 않는다.
- 단점은 논리 주소를 물리주소로 변환할 때 단계가 하나 더 늘어남
    - 주소 변환할 때 시간이 늘어남
    - 세그멘테이션 테이블 → 페이지 테이블
    - 속도 면에서는 좋지 않음
- trade off
    - 뭐 하나가 좋아지면 뭐 하나가 나빠짐

### *가상 메모리*

---

- 물리적인 메모리 크기의 한계를 극복하기 위해 나옴
- 어떻게?
    - 프로세스 이미지를 모두 메모리에 올릴 필요는 없다.
    - 현재 실행에 필요한 부분만 메모리에 올린다.
    - 오류 처리 제외, 배열 일부 제외, 워드프로세스에서 정렬, 표 기능 제외 → 동적 적재와 비슷한 개념
    - 워드프로세스를 메모리에 올리려고 할 때, 정렬이나 코드 같은 기능을 사용하지 않는데 메모리에 올릴 필요가 있을까?
    - 지금 요구되어지는 페이지만 메모리에 올린다. →  Demand Paging

### *요구 페이징(Demand Paging)*

---

- 프로세스 이미지는 backing store에 저장
- 프로세스는 페이지의 집합
- 지금 필요한 페이지만 메모리에 올린다.(load) → 요구되는 페이지만 메모리에 올린다.
- 하드웨어 지원
    - valid 비트 추가된 페이지 테이블
        - 1 : valid bit
        - 0 : invalid bit
        - 메모리에 올라가 있는 페이지와 안올라가있는 테이블을 구분
        - 비트가 0이면
    - backing store(=swap device)
- 일반적으로 Demand Paging = Virtual Memory

### *페이지 결함(Page Fault)*

---

- 페이지가 메모리에 있지 않고, 백킹 스토어에 있음
- 접근하려는 페이지가 메모리에 없다
- Backing Store에서 해당 페이지를 가져온다.
- 과정
    - CPU가 어떤 주소를 냈는데, 거기에 해당되는 페이지 테이블 엔트리 valid bit가 0일 때
    - 그럼 페이지 테이블에서 CPU에게 전기적 신호를 보냄
    - CPU는 하던 일을 중지하고 OS의 Page Fault 처리 루틴을 실행
    - OS는 하드디스크에 있던 페이지를 메인 메모리로 가져옴
    - 페이지 테이블의 내용을 변경해줌(처음 CPU가 냈던 주소의 테이블 내용을 변경, valid bit의 값을 1로 변경)

### *Pure demand paging*

- 백킹스토어에서 메모리로 들고 올 적에 진짜 필요한 애들만 들고 오는 것
- 처음부터 페이지 폴트가 일어남 → 속도가 느림
- 장점
    - 메모리가 절약됨
    - 진짜 필요한 페이지만 들고 오기 때문

### *prepaging*

- 미리 몇 페이지를 들고 오는 것
- 미리 들고 왔기 때문에 메모리는 낭비됨
- 페이지 폴트가 적게 일어나기 때문에 속도는 증가

### Swaping vs Demand Paging

---

- 스와핑은 스왑 디바이스로 왔다가 가는 Swap in, Swap-out의 단위가 프로세스
- 디맨드 페이징은 단위가 페이지임