# 세그멘테이션

- 보호와 공유
- 세그멘테이션

### 보호와 공유

---

- 보호: 해킹 등 방지
    - 모든 주소는 페이지 테이블을 경유하므로
    - 페이지 테이블 엔트리마다 r,w,x 비트를 둠
    - 해당 페이지에 대한 접근 제어 가능
- 공유
    - hwp파일을 3개를 띄우면
        - 하나의 프로그램이 실행될 때는 code, data, stack가 필요함
        - 그런데 세 개의 프로그램에 모두 code, data, stack을 띄운다면 낭비임
        - Code + data +stack 에서 code는 공유 가능(단, non-self-modifying code(스스로 내용을 바꾸지 코드) = reentrant code(재진입 가능 코드) = pure code인 경우)
        - 프로세스의 페이지 테이블 코드 영역이 같은 곳을 가리키게

### 세그멘테이션

---

- 프로세스를 논리적 내용(=세그먼트)으로 잘라서 메모리에 배치
    - 프로세스는 세그먼트의 집합
    - 세그먼트의 크기는 일반적으로 같지 않다.
- 세그먼트를 메모리에 할당
    - MMU 내의 재배치 레지스터 값을 바꿈으로서
    - CPU는 프로세스가 연속된 메모리 공간에 위치한다고 착각
    - MMU는 세그먼트 테이블이 된다.
    - 세그먼트 테이블은 페이징 테이블과 달리 프레임 넘버가 아닌 메모리에서의 시작번지(base)가 들어있다.
    - 세그먼트 테이블은 limit(한계값)이 있음, 다른 세그먼트의 영역에 침범할 수 있기 때문에
    - 한계값과 논리주소를 비교하여 다른 세그먼트를 침범하게 되면 CPU에 인터럽트를 검

### 정리

---

- 프로세스를 메모리에 연속적으로 올리려다 보니 메모리 낭비(hole)이 심함
- 그래서 프로세스를 잘라서 넣기로 함
- 일정 크기로 자르는 것을 페이징 → 보다 일반적
- 논리적 내용으로 자르는 것을 세그멘테이션
- 장단점
    - 세그멘테이션
        - 보호와 공유 측면에서 페이징보다 낫다
        - 보호 측면에서 나은 이유는 페이징에서는 일정 크기로 자르기 때문에 어느 페이지에서는 코드와 데이터가 있고, 어느 페이지에서는 데이터와 스택도 있음
        - 소고기를 예를 들면 부위 상관없이 크기만 일정하게 자름
        - 하지만 세그멘테이션은 부위를 신경쓰며 자르기 때문에, 각 부위가 섞일 걱정이 없음.
        - 코드는 실행할 수 있지만, 데이터는 실행하면 안되는데 그런 부분에서 세그멘테이션이 나음
        - 공유 측면에서 나은 이유는 보호와 비슷함
        - 코드는 공유 가능한데, 페이징에서는 한 페이지에 코드와 데이터가 같이 들어있을 수 있기 때문에
        - 하지만 대부분의 운영체제는 페이징을 사용한다. 이유는 세그멘테이션의 단점이 있기 때문이다.