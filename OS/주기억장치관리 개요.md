# 주기억장치관리 개요

OS는 다양한 역할을 하지만 Process MGMT, Memory MGMT가 가장 중요하다.

### 메모리 역사

---

- Core Memory
- 진공관 메모리
- 트랜지스터 메모리
- 집적회로 메모리: SRAM, DRAM

### 메모리 역사

---

- 1970년대 : 8-bit PC 64KB
- 1980년: 16-bit IBM-PC 640KB > 1MB > 4MB
- 1990년 : 수MB > 수십 MB
- 2000년 : 수백 MB > 수 GB

### 언제나 부족한 메모리

---

- 프로그램 변천
    - 기계어/어셈블리어 작성
    - C언어 ㅈ가성
    - 자바, 객체지향형 언어처리
    - 숫자 처리 > 문자 처리 > 멀티미디어 처리 > BIG DATA
    - 언제나 부족하다.
- 메모리를 어떻게 하면 효과적으로 사용할 수 있을까?
    - 메모리 낭비 없애기
    - 가상 메모리

### 프로그램을 메모리에 올리기

---

- CPU가 메모리에게 몇번지를 읽겠다 라고 보냄
- 메모리는 해당되는 데이터(일반 데이터, 명령)를 CPU에게 보냄
- 입력 : 주소, 출력 : 데이터
- 데이터는 양방향임(CPU가 메모리의 몇번지에 데이터를 저장할 수 있기 때문)

### 소스파일 변천사

---

- `Main.c` → 컴파일 → `Main.o` → 링크(소스코드에서 사용했던 라이브러리를 연결) → `실제 실행 파일` → 로드(메인 메모리로 올림)
- 프로그램 실행
    - code
    - data
    - stack(지역변수, 함수 호출 시 돌아오는 주소 저장)

### 프로그램을 메모리에 올리기

---

- 실행 파일을 메모리에 올리기
    - 메모리 몇 번지에?
        - OS가 없으면 우리가 고민해야함, 다행스럽게 OS가 해줌
        - OS의 메모리 관리 부서 중 로더가 결정
    - 다중 프로그래밍 환경에서는?
        - `Main.exe`느
- MMU 사용
    - 재배치 레지스터
        - OS가 재배치 레지스터의 값을 바꾸어 주기 때문에, 메모리의 몇번지에 올리는가는 중요하지 않음
- 주소 구분
    - 논리주소 vs 물리주소